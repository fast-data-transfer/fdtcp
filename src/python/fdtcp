#!/usr/bin/env python2.7
"""
fdtcp project

this program is client for remote fdtd data transfer services,
communication is done via PYRO (Python Remote Objects)

Supports Python 2.7

Command line options format should follow (to certain extent) srmcp interface:
srmcp help says:

Usage: srmcp [command line options] source(s) destination

 or  : srmcp [command line options] -copyjobfile=<file>
       either source(s) or destination or both should be (an) srm url
       default options can be set in configuration file
       or overridden by the command line options

Report file (--report) is required by PhEDEx. PhEDEx itself makes its own checks
whether or not the files were successfully transferred, but these report flags
are used for debugging. srmcp defines these return codes:
     0 - success
     1 - general error
     2 - file exists, can not overwrite
     3 - user permission error

fdtcp implements only 0 or 1. And also doesn't support partial transfers - so
whole transfer is either considered successful or at error.
If partial transfers are to be reported properly, the report file needs
to be generated by FDT Java since fdtcp can't get such information from
FDT Java - the command either successfully finishes or fails - and whole
transfer which is typically a bunch of files is handled by a single
FDT client, server pair. Consideration of these partial transfers are
certainly not a priority at this stage.
"""
import os
import sys
import copy
import signal
import socket
import re
import datetime

try:
    # force loading fdtcplib.__init__.py (see comment in this file related
    # to PYRO_STORAGE env. variable setting) - must be before first PYRO import
    import apmon
    import Pyro4
    import Pyro4.core
    from Pyro4.errors import PyroError
    from Pyro4.errors import ProtocolError
    from Pyro4.errors import ConnectionClosedError
    from fdtcplib.utils.Executor import ExecutorException
    from fdtcplib.utils.Config import Config
    from fdtcplib.utils.Logger import Logger
    from fdtcplib.common.actions import TestAction
    from fdtcplib.common.actions import ReceivingServerAction
    from fdtcplib.common.actions import SendingClientAction
    from fdtcplib.common.actions import CleanupProcessesAction
    from fdtcplib.common.TransferFile import TransferFile
    from fdtcplib.common.errors import FDTDException, TimeoutException
    from fdtcplib.common.errors import FDTCopyException, FDTCopyShutdownBySignal
    from fdtcplib.common.errors import PortInUseException
    from fdtcplib.utils.Config import ConfigurationException
except ImportError, ex:
    print "Can't import dependency modules: %s" % ex
    sys.exit(1)


class FDTCopy(object):
    """PYRO client / proxy - all interactions with remote FDTD PYRO service
       happen via this object.
    """

    def __init__(self, uri, logger):
        self.logger = logger
        self.uri = uri
        self.logger.debug("%s creating PYRO proxy for URI: '%s'" %
                          (self.__class__.__name__, self.uri))
        try:
            self.proxy = Pyro4.Proxy(self.uri)
        except AttributeError as ex:
            m = "Incorrect URI '%s', could not create PYRO proxy for \
                 FDTD service. Error %s" % (self.uri, ex)
            raise FDTCopyException(m)
        # set timeout - if there is a firewall, usually hangs for long
        # this PYRO solution does not work - still hangs for 3 minutes ...
        # -> solution by signal / SIGALARM
        # self.proxy._setTimeout(num_of_seconds)
        # install signal handlers
        signal.signal(signal.SIGALRM, self._signalHandler)
        signal.signal(signal.SIGHUP, self._signalHandler)
        signal.signal(signal.SIGTERM, self._signalHandler)
        signal.signal(signal.SIGUSR1, self._signalHandler)

    def _signalHandler(self, signum, frame):
        """TODO"""
        del frame
        if signum == signal.SIGALRM:
            self.logger.warn("SIGALRM signal %s caught, raising exception." % signum)
            raise TimeoutException("Timeout exception.")
        m = "Signal %s caught, terminating ... " % signum
        self.logger.fatal(m)
        # raise exception rather than calling .shutdown() directly, this way
        # it can be only shutdown from one place
        raise FDTCopyShutdownBySignal(m)

    def call(self, action):
        """ main call TODO """
        self.logger.debug("Calling '%s' request: %s\n%s ..." %
                          (self.uri, action.__class__.__name__, action))
        try:
            try:
                if action.timeout:
                    signal.alarm(action.timeout)  # raise alarm in timeout seconds
                result = self.proxy.service(action)
            finally:
                signal.alarm(0)  # disable alarm
        except TimeoutException, ex:
            m = "Call to remote PYRO FDTD service timed-out (remote service down, firewall, or ? ...)."
            raise FDTCopyException(m)
        # ProtocolError first, before PyroError
        except ProtocolError, ex:
            m = "ProtocolError during remote PYRO call, reason: %s" % ex
            self.logger.error("PYRO call traceback: %s" % ''.join(Pyro4.util.getPyroTraceback()))
            raise FDTCopyException(m)
        except ConnectionClosedError, ex:
            m = "Connection with remote PYRO service lost, try again."
            raise FDTCopyException(m)
        except PyroError, ex:
            self.logger.error("PYRO call traceback: %s" % ''.join(Pyro4.util.getPyroTraceback()))
            m = "PyroError during remote PYRO call, reason: %s" % ex
            raise FDTCopyException(m)
        else:
            # self.logger.debug("Call to remote PYRO service successful.")
            return result

    def perform(self, action):
        """TODO doc """
        result = self.call(action)
        if result.status == 0:
            self.logger.info("Success, response: %s" % result)
            return result
        else:
            m = ("Error occurred on host %s id: %s, reason: %s\n"
                 "remote log:\n%s\n" % (result.host, result.id, result.msg, result.log))
            raise FDTCopyException(m)


class Transfer(object):
    """
    Transfer of one or more files from host A to host B.
    Implements group transfers.
    """
    def __init__(self, conf, apMon, logger):
        self.id = None  # transfer process ID
        self.hostSrc = None  # host name
        self.hostDest = None  # host name
        self.portSrc = None  # port on which fdtd at source site runs
        self.portDest = None  # port on which fdtd at destination site runs
        self.sender = None  # FDTCopy instance to the remote sending FDT client
        self.receiver = None  # FDTCopy instances to the remote receiving FDT server
        self.files = []  # list of TransferFile - will be translated into fileList
        self.log = None  # transfer log as returned from remote FDTD service
        self.result = None  # result of transfer on hosts (or group transfers) level
        self.toCleanup = []  # URI of remote parties to send CleanupProcessAction to
        self.conf = conf
        self.apMon = apMon  # instance for ApMon, MonALISA monitoring
        self.logger = logger
        # if only one will be specified, it will not be a problem. This needs to be printed about problem!
        self.circuitServerIP = conf.get('servercircuitip')
        self.circuitClientIP = conf.get('clientcircuitip')
        self.portServer = conf.get('portServer')
        self.monID = conf.get('monID')

    def __str__(self):
        numFiles = len(self.files)
        if numFiles > 1:
            m = "%s -> %s (%s files)" % (self.hostSrc, self.hostDest, numFiles)
        else:
            m = ("%s:%s -> %s:%s" % (self.hostSrc, self.files[0].fileSrc,
                                     self.hostDest, self.files[0].fileDest))
        return m

    def setUp(self, hostSrc, portSrc, hostDest, portDest, trFile):
        """TODO doc """
        self.files.append(trFile)
        self.hostSrc, self.hostDest = hostSrc, hostDest
        self.portSrc, self.portDest = portSrc, portDest

        uriSrc = "PYROLOC://" + hostSrc + ":" + portSrc + "/FDTDService"
        uriDest = "PYROLOC://" + hostDest + ":" + portDest + "/FDTDService"

        # assuming FDT Java client is sender (at respective remote FDTD service)
        # assuming FDT Java server is receiver (at respective remote FDTD service)
        # create local PYRO proxies for remote FDTD services
        try:
            self.sender = FDTCopy(uriSrc, self.logger)
            self.receiver = FDTCopy(uriDest, self.logger)
        except FDTCopyException, ex:
            m = "Transfer %s failed, reason: %s" % (self, ex)
            self.logger.error(m)
            self.log = m
            self.result = 1

    def addFile(self, trFile):
        """TODO doc """
        self.files.append(trFile)

    def performTransfer(self):
        """TODO doc """
        self.logger.info("Starting transfer  %s" % self)

        if self.result is not None:
            self.logger.warn("Skipping transfer %s (already failed)." % self)
            return

        # timeout is used only on TestActions (testing mutual connection)
        # id of the initial action (this test (TestAction)) is later used in all
        # subsequent actions related to this particular transfer
        timeout = int(self.conf.get("timeout"))
        testAction = TestAction(self.hostSrc, self.hostDest, timeout=timeout)
        self.id = testAction.id

        self.logger.info("Testing remote parties availability, "
                         "transfer id: '%s' ..." % testAction.id)

        self.receiver.perform(testAction)
        self.sender.perform(testAction)

        remoteGridUserSrc = "dynes"
        remoteGridUserDest = "dynes"
        # find out client IP address, server will need it (-f <allowedIPsList>) when starting
        clientIP = socket.gethostbyname(self.hostSrc)
        self.logger.debug("Client IP address is: '%s'" % clientIP)

        # since the separate log file may not be closed properly once the
        # ReceivingServer request is send, register the request for possible
        # cleaning now (issue found during ticket:5#comment:24)
        # no exception was raised, remote process must be running, register for
        # clean up (remote process may however terminate normally, then shall be
        # removed from the container of processes at the remote party)
        self.toCleanup.append(self.receiver.uri)

        # start receiving server first, information on its port will need the client
        # destFiles - list if files at destination - just check (#36)
        destFiles = [f.fileDest for f in self.files]
        options = dict(gridUserDest=remoteGridUserDest, clientIP=clientIP,
                       destFiles=destFiles, circuitServerIP=self.circuitServerIP,
                       circuitClientIP=self.circuitClientIP,
                       portServer=self.portServer, monID=self.monID)
        recvServerAction = ReceivingServerAction(self.id, options)
        result = self.receiver.perform(recvServerAction)
        serverFDTPort = result.serverPort
        self.logger.info("Remote FDT server: %s:%s" % (result.host, serverFDTPort))

        # calling the client is synchronous action - waiting until it finishes
        # if the client hangs without progress - may want to kill such remote
        # process, thus register the remote URI into clean up local container
        # if something goes wrong, this remote URI later receives CleanupAction
        # to kill its running processes
        self.toCleanup.append(self.sender.uri)

        # start sending FDT client which initiates the transfer process
        options = dict(port=serverFDTPort, hostDest=self.hostDest,
                       transferFiles=self.files,
                       gridUserSrc=remoteGridUserSrc,
                       circuitServerIP=self.circuitServerIP,
                       circuitClientIP=self.circuitClientIP,
                       portServer=self.portServer, monID=self.monID)
        sndClientAction = SendingClientAction(self.id, options)
        # this command will stop the execution flow, for very very long if
        # the transfer data is bulky - status monitoring via MonALISA
        # using the transfer id
        result = self.sender.perform(sndClientAction)

        self.logger.info("Transfer result: %s, logs (FDT sending client):\n%s" % (result, result.log))

        self.result = result.status
        # don't put the log there for now, but in case of failure it puts the
        # log into result and then into report file
        # self.log = result.log

        # clean up remote processes
        # the server - FDT Java server is run with -S - it gets automatically shut
        #    once the transfer is over
        # the client - if everything was all right (client not hanging), it
        #    has already successfully finished (and the key of the process
        #    has been removed from the container with the client)
        # yet call the cleanup at both sides explicitly
        self.performCleanup(waitTimeout=True)

    def performCleanup(self, waitTimeout=True):
        """
        waitTimeout: whether fdtd shall wait timeout period before killing
            the process.
        """
        if len(self.toCleanup) < 1:
            self.logger.info("Cleanup action - nothing to clean up, transfer: %s" % self)
            return

        cleanupStartTime = datetime.datetime.now()

        self.logger.info("Cleanup action, transfer: %s - terminate remote processes ..." % self)
        self.logger.debug("%s items in the clean up container." % len(self.toCleanup))
        timeout = int(self.conf.get("timeout"))
        cl = CleanupProcessesAction(self.id, timeout=timeout, waitTimeout=waitTimeout)

        # iterate the container from the tail, the last one added was client and
        # client should have finished by this point anyway ...
        self.toCleanup.reverse()
        # have to have another copy of the container to iterate
        # over, the original will be shrunk
        tmpToCleanup = copy.deepcopy(self.toCleanup)

        for uri in tmpToCleanup:
            # have to try to get another PYRO proxy, should the previous one be blocked
            # and every subsequent call on it will time out and will not even be
            # received by fdtd (ticket #26, though this method already had another
            # FDTCopy, resp. PYRO instantiation)
            fdtCopy = FDTCopy(uri, self.logger)
            try:
                fdtCopy.perform(cl)
            except FDTCopyException, ex:
                self.logger.error("During clean up: %s" % ex)
            # TODO
            # have to be specific about exceptions here, shall exhaust the whole list though
            # likely FDTDException may happen here and is translated into FDTCopyException
            # above
            #except Exception as ex:
            #    self.logger.error("Unspecified exception during clean up: %s" % ex)

            fdtCopy.proxy._release()
            self.toCleanup.pop()  # reverse, then pop the last item, iterating from the end...

        cleanupEndTime = datetime.datetime.now()
        cleanupTime = (cleanupEndTime - cleanupStartTime).seconds
        par = dict(id=self.id, cleanup=cleanupTime)
        self.logger.debug("Clean up lasted: %s [s]." % cleanupTime)
        if self.apMon:
            self.logger.debug("Sending data to ApMon ...")
            self.logger.info(par)
            self.apMon.sendParameters("fdtcp", None, par)


class Transfers(object):
    """
    Wrapper for all transfers, does copyjobfile processing if specified.
    """
    def __init__(self, conf, apMon, logger):
        # dict of Transfer class instances
        # key is hostPortSrc+hostPortDest - processing for copyjobfile - transfers grouping
        self.transfers = {}

        if not conf.get("copyjobfile"):
            # consider no copyjobfile scenario - must be a single file
            self._setTransfer(conf.get("urlSrc"), conf.get("urlDest"), apMon, conf, logger)
        else:
            self._processCopyJobFile(conf, apMon, logger)

    def _setTransfer(self, urlSrc, urlDest, apMon, conf, logger):
        """Initialise instance of Transfer class and set up properties.
           URL form: fdt://gridftp01.ultralight.org:8443//mnt/hadoop/path/to/file
                     fdt://.*:[0-9]+/?.*
           Aggregates the same source, destination hosts into group transfer.
           Same source, destination value is defined by hostSrc:portSrc-hostDest:postDest
        """
        pattern = re.compile("fdt://(?P<host>.*):(?P<port>[0-9]+)/?(?P<file>/.*)")

        if not pattern.match(urlSrc):
            raise FDTCopyException("Wrong format of '%s'" % urlSrc)
        if not pattern.match(urlDest):
            raise FDTCopyException("Wrong format of '%s'" % urlDest)

        m = pattern.search(urlSrc)
        hostSrc, portSrc, fileSrc = m.group("host"), m.group("port"), m.group("file")

        m = pattern.search(urlDest)
        hostDest, portDest, fileDest = m.group("host"), m.group("port"), m.group("file")

        # check if such transfer exists, if so, aggregate, if not, create it
        key = "%s:%s-%s:%s" % (hostSrc, portSrc, hostDest, portDest)
        try:
            transfer = self.transfers[key]
            transfer.addFile(TransferFile(fileSrc, fileDest))
        except KeyError:
            transfer = Transfer(conf, apMon, logger)
            trFile = TransferFile(fileSrc, fileDest)
            transfer.setUp(hostSrc, portSrc, hostDest, portDest, trFile)
            self.transfers[key] = transfer

    def _processCopyJobFile(self, conf, apMon, logger):
        """
        Process copyjobfile - list of pairs urlSrc urlDest (resp. FROM_PFN TO_PFN).
        """
        fileName = conf.get("copyjobfile")
        try:
            lines = open(fileName, 'r').readlines()
        except IOError, ex:
            raise FDTCopyException("Can't read '%s', reason: %s" % (fileName, ex))

        try:
            for index, line in enumerate(lines):
                line = line.strip()
                urls = line.split()
                urlSrc, urlDest = urls[0], urls[1]
                self._setTransfer(urlSrc, urlDest, apMon, conf, logger)
            else:
                if len(self.transfers) == 0:
                    raise FDTCopyException("No transfer requests found in '%s'" % fileName)
        except IndexError, ex:
            lineNum = index + 1  # count lines from 1 for user-friendly error message
            m = "Can't parse file '%s', line: '%s' line number: %s, reason: %s" % (fileName, line, lineNum, ex)
            raise FDTCopyException(m)


class ConfigFDTCopy(Config):
    """Class holding various options and settings which are either predefined
       in the configuration file, overriding from command line options is
       considered.
    """
    def __init__(self, args):
        usage = \
                """usage: %prog [options] source_url destination_url
                   %prog [options] --copyjobfile=filelist
                   %prog fdt://host1:port/path1/to/file1 fdt://host2:port/path2/to/file2
                """
        # 1 - shall point to the same directory
        # integer mandatory configuration options
        self.mandatoryInt = ["timeout"]
        # string mandatory configuration options
        self.mandatoryStr = ["debug"]

        self.options = {}
        currDir = os.path.abspath(__file__).rsplit(os.sep, 1)[0]
        currDirConfig = os.path.join(currDir, "fdtcp.conf")
        # consider only config file being in the same directory
        # as well as in the system config directory location
        locations = [currDirConfig, "/etc/fdtcp/fdtcp.conf"]
        Config.__init__(self, args, locations, usage=usage,
                        mandInt=self.mandatoryInt, mandStr=self.mandatoryStr)

    def _defineCommandLineOptions(self):
        """TODO doc """
        helps = "the path to the report file"
        self.parser.add_option("-r", "--report", help=helps)
        helps = "debug output level, for possible values see the config file"
        self.parser.add_option("-d", "--debug", help=helps)
        helps = "file containing source_url destination_url pairs"
        self.parser.add_option("-f", "--copyjobfile", help=helps)
        helps = "print this help"
        self.parser.add_option("-h", "--help", help=helps, action='help')
        helps = "configuration file for fdcp"
        self.parser.add_option("-c", "--config", help=helps)
        helps = "timeout in seconds for initial connectivity tests"
        self.parser.add_option("-t", "--timeout", help=helps)
        helps = "optional argument - output log file"
        self.parser.add_option("-l", "--logFile", help=helps)
        helps = "optional argument for specifying client circuit IP"
        self.parser.add_option("-i", "--clientcircuitip", help=helps)
        helps = "optional argument for specifying server circuit IP"
        self.parser.add_option("-y", "--servercircuitip", help=helps)
        helps = "Port which user for transfers. This overcomes the default configuration on the server"
        self.parser.add_option("-p", "--portServer", help=helps)
        helps = "Monitoring ID with which to report transfer statistics"
        self.parser.add_option("-m", "--monID", help=helps)


    def processCommandLineOptions(self, args):
        """This method gets called from base class"""
        self._defineCommandLineOptions()

        # opts - new processed options, items defined above appear as attributes
        # args - remainder of the input array
        opts, args = self.parser.parse_args(args=args)

        if not opts.copyjobfile:
            try:
                opts.urlSrc = args[-2]
                opts.urlDest = args[-1]
            except IndexError, ex:
                self.parser.print_help()
                m = "Incorrect command line options, see --help. Error %s" % ex
                raise ConfigurationException(m)
        else:
            if len(args) > 0:
                m = ("Incorrect command line options, can't take further "
                     "arguments along with --copyjobfile, see --help ")
                raise ConfigurationException(m)

        # want to have _options a dictionary, rather than instance
        # some Values class from within optparse.OptionParser
        # self._options = opts
        self.options = eval(str(opts))


def generateReport(transfer, fileName):
    """
    Generate the report file (if required).
    Do not check for any exceptions at this stage, they will be propagated.
    Should multiprocessing transfers be implemented, exclusive access here
    has to be ensured.
    """
    t = transfer
    f = open(fileName, "a+")
    for trf in t.files:
        o = ("fdt://%s:%s  fdt://%s:%s  %s  %s\n" % (t.hostSrc, trf.fileSrc,
                                                     t.hostDest, trf.fileDest,
                                                     t.result, t.log))
        f.write(o)
        f.flush()
    f.close()


def main():
    """ TODO doc """
    # all values and action information held in the conf object
    optBackup = sys.argv[:]
    try:
        conf = ConfigFDTCopy(sys.argv[1:])
        conf.sanitize()
    except ConfigurationException, ex:
        print "fdtcp failed to start, reason: %s" % ex
        sys.exit(1)

    logger = Logger(name="fdtcp", logFile=conf.options.get("logFile"),
                    level=conf.options.get("debug"))
    # ticket #35 - mercurial expandable keywords in the code
    # information from the SCM (expandable keywords)
    versionInfo = dict(Revision="$Revision: cf25e731af0a $", Tags="$Tags:  $")
    logger.info("fdtcp starting ... version: %s", logger.pprintFormat(versionInfo))
    logger.debug("Search sys.path:\n%s\n", logger.pprintFormat(sys.path))
    logger.debug("PYRO_STORAGE: '%s'", os.environ.get("PYRO_STORAGE"))

    logger.debug("Input command line arguments: '%s'", optBackup)
    #logger.debug("Configuration values (processed):\n%s\n" %
    #             logger.pprintFormat(conf.options))

    apMon = None
    apMonDestConf = conf.options.get("apMonDestinations")
    if apMonDestConf:
        apMonDestinations = tuple(apMonDestConf.split(','))
        logger.info("Initializing MonALISA ApMon, destinations: %s ...", (apMonDestinations,))
        apMon = apmon.ApMon(apMonDestinations)
        apMon.enableBgMonitoring(True)
    else:
        logger.info("MonALISA ApMon is not enabled, no destinations provided.")

    # use DNS names rather than IP address
    # Pyro.config.PYRO_DNS_URI = True
    # TODO: Force it from config to be a hostname...

    try:
        transfers = Transfers(conf, apMon, logger)
    except FDTCopyException, ex:
        logger.fatal(ex)
        # everything failed - all transfers
        if conf.options.get("report"):
            # TODO
            # if necessary - may take just the input or the copyjobfile
            # and generate something with everything assigned 1
            logger.error("Report file was required, can't generate it with "
                         "failure on this stage ...")
        if apMon:
            apMon.free()
        logger.warn("fdtcp finished.")
        logger.close()
        sys.exit(1)

    # main result status of the fdtcp app run, any failed transfer
    # from transfers.transfers causes whole app status set to 1
    appExitStatus = 0
    try:
        for transfer in transfers.transfers.values():
            try:
                transfer.performTransfer()
                transfer.result = 0
            except FDTCopyException, ex:
                logger.error("Transfer failed, reason: %s", ex)
                transfer.result = 1
                transfer.log = ex
                appExitStatus = 1
            except PortInUseException as ex:
                logger.error("Transfer failed, reason seems Port In Use %s", ex)
                transfer.result = 1
                transfer.log = ex
                appExitStatus = 2
            except ExecutorException, ex:
                # TODO
                # this type of exception is too low-level, should be wrapper on an upper level
                logger.error("Transfer failed, reason: %s", ex)
                transfer.result = 1
                transfer.log = ex
                appExitStatus = 1
            except FDTDException, ex:
                # TODO
                # this may (most likely) only be raised from authChain from Executor
                # which needs to be made more general and not bound (e.g. by exception
                # types it raises) to fdtd
                logger.error("Transfer failed, reason: %s", ex)
                transfer.result = 1
                transfer.log = ex
                appExitStatus = 1
            except Exception, ex:
                m = "Exception was caught ('%s'), reason: %s" % (ex.__class__.__name__, ex)
                logger.error(m)
                # will also print remote PYRO traceback
                logger.fatal(''.join(Pyro4.util.getPyroTraceback()))
                transfer.result = 1
                transfer.log = m
                appExitStatus = 1
            except KeyboardInterrupt:
                m = "Interrupted from keyboard."
                logger.fatal(m + " Please wait  ...")
                transfer.result = 1
                transfer.log = m
                appExitStatus = 1
                break
    finally:
        for transfer in transfers.transfers.values():
            try:
                try:
                    # performCleanup() should have been called after each
                    # transfer was performed, this is for the case that exception
                    # happened above - or if fdtcp received a signal - on both of
                    # these conditions, do not let fdtd wait timeout period until
                    # the processes may finish on their own
                    transfer.performCleanup(waitTimeout=False)
                except IOError as er:
                    logger.error("Got IOError: %s", er)
                #except Exception, ex:
                #    logger.error("Exception during cleanup, reason: %s" % ex)
                # check if the actual FDTCopy attribute exists - might have failed while creating it
                if transfer.sender:
                    transfer.sender.proxy._release()
                if transfer.receiver:
                    transfer.receiver.proxy._release()
            finally:
                fileName = conf.options.get("report")
                if fileName:
                    logger.info("Going to generate report file '%s' for this transfer ...", fileName)
                    generateReport(transfer, fileName)
        if apMon:
            apMon.free()
        logger.debug("fdtcp finished (exit status: %s).", appExitStatus)
        logger.close()
        sys.exit(appExitStatus)


if __name__ == "__main__":
    main()
